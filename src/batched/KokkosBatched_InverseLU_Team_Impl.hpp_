#ifndef __KOKKOSBATCHED_INVERSELU_TEAM_IMPL_HPP__
#define __KOKKOSBATCHED_INVERSELU_TEAM_IMPL_HPP__


/// \author Vinh Dang (vqdang@sandia.gov)

#include "KokkosBatched_Util.hpp"
#include "KokkosBatched_Trsm_Team_Impl.hpp"


namespace KokkosBatched {
  namespace Experimental {
    ///
    /// Team Impl
    /// =========

    ///
    /// InverseLU no piv
    ///
    
    template<typename MemberType>
    struct TeamInverseLU<MemberType,Algo::InverseLU::Unblocked> {
      template<typename AViewType,
               typename WViewType>
      KOKKOS_INLINE_FUNCTION
      static int
      invoke(const MemberType &member, const AViewType &A, const WViewType &W,
             const typename MagnitudeScalarType<typename AViewType::non_const_value_type>::type tiny = 0) {
        static_assert(AViewType::rank == 2, "A should have two dimensions");
        static_assert(WViewType::rank == 1, "W should have one dimension");
        static_assert(std::is_same<typename AViewType::memory_space, typename WViewType::memory_space>::value, "A and W should be on the same memory space");
        assert(A.span()*sizeof(typename AViewType::value_type) <= W.span()*sizeof(typename WViewType::value_type));

        typedef typename AViewType::value_type ScalarType;
        auto B = Kokkos::View(W.data(), A.extent(0), A.extent(1));

        ScalarType one(1.0);

#if defined(KOKKOS_ENABLE_PRAGMA_UNROLL)
#pragma unroll
#endif
        for (int i=0;i<n;++i) {
            B(i,i) = one;
        }

        //First, compute U inverse by solving the system U*Uinv = I for Uinv
        TeamTrsm<MemberType,Side::Left,Uplo::Upper,Trans::NoTranspose,Diag::NonUnit,Algo::Trsm::Unblocked>::invoke(member, one, A, B);

        //Second, compute A inverse by solving the system Ainv*L = Uinv for Ainv
        TeamTrsm<MemberType,Side::Right,Uplo::Lower,Trans::NoTranspose,Diag::Unit,Algo::Trsm::Unblocked>::invoke(member, one, A, B);

        Kokkos::deep_copy( A, B );
        return 0;
      }
    };
    
    template<typename MemberType>
    struct TeamInverseLU<MemberType,Algo::InverseLU::Blocked> {
      template<typename AViewType,
               typename WViewType>
      KOKKOS_INLINE_FUNCTION
      static int
      invoke(const MemberType &member, const AViewType &A, const WViewType &W,
             const typename MagnitudeScalarType<typename AViewType::non_const_value_type>::type tiny = 0) {
        static_assert(AViewType::rank == 2, "A should have two dimensions");
        static_assert(WViewType::rank == 1, "W should have one dimension");
        static_assert(std::is_same<typename AViewType::memory_space, typename WViewType::memory_space>::value, "A and W should be on the same memory space");
        assert(A.span()*sizeof(typename AViewType::value_type) <= W.span()*sizeof(typename WViewType::value_type));

        typedef typename AViewType::value_type ScalarType;
        auto B = Kokkos::View(W.data(), A.extent(0), A.extent(1));

        ScalarType one(1.0);

#if defined(KOKKOS_ENABLE_PRAGMA_UNROLL)
#pragma unroll
#endif
        for (int i=0;i<n;++i) {
            B(i,i) = one;
        }

        //First, compute U inverse by solving the system U*Uinv = I for Uinv
        TeamTrsm<MemberType,Side::Left,Uplo::Upper,Trans::NoTranspose,Diag::NonUnit,Algo::Trsm::Blocked>::invoke(member, one, A, B);

        //Second, compute A inverse by solving the system Ainv*L = Uinv for Ainv
        TeamTrsm<MemberType,Side::Right,Uplo::Lower,Trans::NoTranspose,Diag::Unit,Algo::Trsm::Blocked>::invoke(member, one, A, B);

        Kokkos::deep_copy( A, B );
        return 0;
      }
    };

  }
}

#endif
