#ifndef __KOKKOSBATCHED_INVERSELU_SERIAL_IMPL_HPP__
#define __KOKKOSBATCHED_INVERSELU_SERIAL_IMPL_HPP__


/// \author Vinh Dang (vqdang@sandia.gov)

#include "KokkosBatched_Util.hpp"
#include "KokkosBatched_Trsm_Serial_Impl.hpp"


namespace KokkosBatched {
  namespace Experimental {
    ///
    /// Serial Impl
    /// =========

    ///
    /// InverseLU no piv
    ///

#if                                                     \
  defined(__KOKKOSBATCHED_INTEL_MKL__) &&               \
  defined(__KOKKOSBATCHED_INTEL_MKL_BATCHED__) &&       \
  defined(__KOKKOSBATCHED_INTEL_MKL_COMPACT_BATCHED__)
    template<>
    template<typename AViewType,
             typename WViewType>
    KOKKOS_INLINE_FUNCTION
    int
    SerialInverseLU<Algo::InverseLU::CompactMKL>::
    invoke(const AViewType &A,
           const WViewType &W,
           const typename MagnitudeScalarType<typename AViewType::non_const_value_type>::type tiny) {
      typedef typename AViewType::value_type vector_type;
      //typedef typename vector_type::value_type value_type;

      const int
        m = A.dimension(0),
        n = A.dimension(1);

      static_assert(is_vector<vector_type>::value, "value type is not vector type");      
      static_assert(vector_type::vector_length == 4 || vector_type::vector_length == 8, 
                    "AVX, AVX2 and AVX512 is supported");
      const MKL_COMPACT_PACK format = vector_type::vector_length == 8 ?  MKL_COMPACT_AVX512 : MKL_COMPACT_AVX;

      int r_val = 0;
      if (A.stride_0() == 1) {
        //mkl_dgetrfnp_compact(MKL_COL_MAJOR, 
        //                     m, n, 
        //                     (double*)A.data(), A.stride_1(), 
        //                     (MKL_INT*)&r_val, format, (MKL_INT)vector_type::vector_length);

        //void mkl_dgetrfnp_compact (MKL_LAYOUT layout, MKL_INT m, MKL_INT n, double * ap, MKL_INT ldap, 
        //                           MKL_INT * info, MKL_COMPACT_PACK format, MKL_INT nm);

        //void mkl_dgetrinp_compact (MKL_LAYOUT layout, MKL_INT n, double * ap, MKL_INT ldap, double * work, 
        //                           MKL_INT lwork, MKL_INT * info, MKL_COMPACT_PACK format, MKL_INT nm);
        mkl_dgetrinp_compact (MKL_COL_MAJOR, n, 
                              (double*)A.data(), A.stride_1(), 
                              (double*)W.data(), n*n, 
                              (MKL_INT*)&r_val, format, (MKL_INT)vector_type::vector_length);

      } else if (A.stride_1() == 1) {
        //mkl_dgetrfnp_compact(MKL_ROW_MAJOR, 
        //                     m, n, 
        //                     (double*)A.data(), A.stride_0(), 
        //                     (MKL_INT*)&r_val, format, (MKL_INT)vector_type::vector_length);
        mkl_dgetrinp_compact (MKL_ROW_MAJOR, n, 
                              (double*)A.data(), A.stride_0(), 
                              (double*)W.data(), n*n, 
                              (MKL_INT*)&r_val, format, (MKL_INT)vector_type::vector_length);
      } else {
        r_val = -1;
      }
      return r_val;
    }
#endif

    template<>
    template<typename AViewType,
             typename WViewType>
    KOKKOS_INLINE_FUNCTION
    int
    SerialInverseLU<Algo::InverseLU::Unblocked>::
    invoke(const AViewType &A, 
           const WViewType &W,
           const typename MagnitudeScalarType<typename AViewType::non_const_value_type>::type tiny) {
        static_assert(AViewType::rank == 2, "A should have two dimensions");
        static_assert(WViewType::rank == 1, "W should have one dimension");
        static_assert(std::is_same<typename AViewType::memory_space, typename WViewType::memory_space>::value, "A and W should be on the same memory space");
        assert(A.span()*sizeof(typename AViewType::value_type) <= W.span()*sizeof(typename WViewType::value_type));

        typedef typename AViewType::value_type ScalarType;
        auto B = Kokkos::View(W.data(), A.extent(0), A.extent(1));

        ScalarType one(1.0);

#if defined(KOKKOS_ENABLE_PRAGMA_UNROLL)
#pragma unroll
#endif
        for (int i=0;i<n;++i) {
            B(i,i) = one;
        }

        //First, compute U inverse by solving the system U*Uinv = I for Uinv
        SerialTrsm<Side::Left,Uplo::Upper,Trans::NoTranspose,Diag::NonUnit,Algo::Trsm::Unblocked>::invoke(one, A, B);
        //Second, compute A inverse by solving the system Ainv*L = Uinv for Ainv
        SerialTrsm<Side::Right,Uplo::Lower,Trans::NoTranspose,Diag::Unit,Algo::Trsm::Unblocked>::invoke(one, A, B);

        Kokkos::deep_copy( A, B );
        return 0;
    }
    
    template<>
    template<typename AViewType,
             typename WViewType>
    KOKKOS_INLINE_FUNCTION
    int
    SerialInverseLU<Algo::InverseLU::Blocked>::
    invoke(const AViewType &A,
           const WViewType &W,
           const typename MagnitudeScalarType<typename AViewType::non_const_value_type>::type tiny) {
        static_assert(AViewType::rank == 2, "A should have two dimensions");
        static_assert(WViewType::rank == 1, "W should have one dimension");
        static_assert(std::is_same<typename AViewType::memory_space, typename WViewType::memory_space>::value, "A and W should be on the same memory space");
        assert(A.span()*sizeof(typename AViewType::value_type) <= W.span()*sizeof(typename WViewType::value_type));

        typedef typename AViewType::value_type ScalarType;
        auto B = Kokkos::View(W.data(), A.extent(0), A.extent(1));

        ScalarType one(1.0);

#if defined(KOKKOS_ENABLE_PRAGMA_UNROLL)
#pragma unroll
#endif
        for (int i=0;i<n;++i) {
            B(i,i) = one;
        }

        //First, compute U inverse by solving the system U*Uinv = I for Uinv
        SerialTrsm<Side::Left,Uplo::Upper,Trans::NoTranspose,Diag::NonUnit,Algo::Trsm::Blocked>::invoke(one, A, B);
        //Second, compute A inverse by solving the system Ainv*L = Uinv for Ainv
        SerialTrsm<Side::Right,Uplo::Lower,Trans::NoTranspose,Diag::Unit,Algo::Trsm::Blocked>::invoke(one, A, B);

        Kokkos::deep_copy( A, B );
        return 0;
    }

  }
}

#endif
